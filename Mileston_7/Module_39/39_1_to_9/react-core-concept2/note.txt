///////////////39-2 Different ways to handle events in React//////////////
ðŸ§© Definition

This App component demonstrates four different ways to handle button clicks in React using both regular and arrow functions.

ðŸ’¡ Example Breakdown

Normal Function Declaration

function handleClick() {
  alert('I am clicked');
}


ðŸ‘‰ Bound when the component renders â€” called in the onClick directly.

<button onClick={handleClick}>Click with normal function</button>


Arrow Function Declaration

const handleClick2 = () => {
  alert('I am clicked 2');
}


ðŸ‘‰ Works the same, just written in modern arrow syntax.

<button onClick={handleClick2}>Click2 with arrow function</button>


Inline Function (inside JSX)

<button onClick={() => alert('I am clicked 3')}>Click3 function in event handler</button>


ðŸ‘‰ Function is defined directly inside the onClick.
âš ï¸ Creates a new function every render (not a problem here, but not efficient for large apps).

Event Handler with Argument

const handleAddnum = (num) => {
  alert(num + 5);
}


ðŸ‘‰ You can pass arguments using an inline function:

<button onClick={() => handleAddnum(10)}>Click to add 5</button>


âœ… Shows 15 in the alert.

âš™ï¸ Use Case

This example teaches different click-handling patterns youâ€™ll use throughout React apps â€” for buttons, form actions, modals, and more







/////////////////39-3 A simple Introduction to State change in React//////////////
ðŸ§© Definition

This component uses Reactâ€™s useState hook to store and update a counter when the user clicks a button.

ðŸ’¡ Example Breakdown
const [count, setCount] = useState(0)


count â†’ holds the current number (initial value = 0).

setCount â†’ function used to update that number.
When called, React re-renders the component with the new value.

âš™ï¸ Event Handler
const handleAdd = () => {
  setCount(count + 5)
}


Each click increases the count by 5.

The UI automatically updates â€” no manual DOM changes needed (React does it for you).

ðŸ’» Rendered Output

When you click the Add button:

Count: 0  â†’ 5  â†’ 10  â†’ 15  â†’ ...

âœ… Use Case

This same logic can power:

A shopping cart item count ðŸ›’

A game score counter ðŸŽ®

A likes/upvotes feature ðŸ‘

A dynamic total in any calculation





39-4 Understand the concept of useState and react hooks///////////////////////////////////////

This combined setup (App.jsx + Batsman.jsx) is absolutely correct and clean React code â€” it will run smoothly with no errors in Vite or Create React App.

Letâ€™s go through a detailed but clear explanation ðŸ‘‡

ðŸ§© Whatâ€™s Happening in Your Code
1. Batsman.jsx â€” Child Component

Youâ€™ve created a self-contained React component that manages its own state:

const [runs, setRuns] = useState(0)
const [sixs, setSixs] = useState(0)
const [fours, setFours] = useState(0)


Each state tracks a separate value â€” total runs, sixes, and fours.

âœ… Event Handlers
const handleSingle = () => setRuns(runs + 1)
const handleFour = () => {
  setRuns(runs + 4)
  setFours(fours + 1)
}
const handleSix = () => {
  setRuns(runs + 6)
  setSixs(sixs + 1)
}


Each button click updates both the total score and the related count correctly.
React automatically re-renders the UI when any of these state values change.

âœ… UI Output
<p>Total Fours: {fours} and Total sixes: {sixs}</p>
<h2>Score: {runs}</h2>


Every click instantly updates the displayed data â€” no manual DOM manipulation needed.

2. App.jsx â€” Parent Component

Here you are importing and rendering the Batsman component:

import Batsman from './Batsman'

function App() {
  return (
    <>
      <Batsman></Batsman>
    </>
  )
}


âœ… Batsman is being used as a child component, and since it handles its own state internally, no props or extra setup is required.

ðŸ§  Why This Is Great React Practice

Youâ€™re keeping state local to the component that uses it (Batsman).

App remains clean and focuses only on layout or routing.

Each component does one job â€” this is perfect React design.