///////////////39-2 Different ways to handle events in React//////////////
ğŸ§© Definition

This App component demonstrates four different ways to handle button clicks in React using both regular and arrow functions.

ğŸ’¡ Example Breakdown

Normal Function Declaration

function handleClick() {
  alert('I am clicked');
}


ğŸ‘‰ Bound when the component renders â€” called in the onClick directly.

<button onClick={handleClick}>Click with normal function</button>


Arrow Function Declaration

const handleClick2 = () => {
  alert('I am clicked 2');
}


ğŸ‘‰ Works the same, just written in modern arrow syntax.

<button onClick={handleClick2}>Click2 with arrow function</button>


Inline Function (inside JSX)

<button onClick={() => alert('I am clicked 3')}>Click3 function in event handler</button>


ğŸ‘‰ Function is defined directly inside the onClick.
âš ï¸ Creates a new function every render (not a problem here, but not efficient for large apps).

Event Handler with Argument

const handleAddnum = (num) => {
  alert(num + 5);
}


ğŸ‘‰ You can pass arguments using an inline function:

<button onClick={() => handleAddnum(10)}>Click to add 5</button>


âœ… Shows 15 in the alert.

âš™ï¸ Use Case

This example teaches different click-handling patterns youâ€™ll use throughout React apps â€” for buttons, form actions, modals, and more







/////////////////39-3 A simple Introduction to State change in React//////////////
ğŸ§© Definition

This component uses Reactâ€™s useState hook to store and update a counter when the user clicks a button.

ğŸ’¡ Example Breakdown
const [count, setCount] = useState(0)


count â†’ holds the current number (initial value = 0).

setCount â†’ function used to update that number.
When called, React re-renders the component with the new value.

âš™ï¸ Event Handler
const handleAdd = () => {
  setCount(count + 5)
}


Each click increases the count by 5.

The UI automatically updates â€” no manual DOM changes needed (React does it for you).

ğŸ’» Rendered Output

When you click the Add button:

Count: 0  â†’ 5  â†’ 10  â†’ 15  â†’ ...

âœ… Use Case

This same logic can power:

A shopping cart item count ğŸ›’

A game score counter ğŸ®

A likes/upvotes feature ğŸ‘

A dynamic total in any calculation





39-4 Understand the concept of useState and react hooks///////////////////////////////////////

This combined setup (App.jsx + Batsman.jsx) is absolutely correct and clean React code â€” it will run smoothly with no errors in Vite or Create React App.

Letâ€™s go through a detailed but clear explanation ğŸ‘‡

ğŸ§© Whatâ€™s Happening in Your Code
1. Batsman.jsx â€” Child Component

Youâ€™ve created a self-contained React component that manages its own state:

const [runs, setRuns] = useState(0)
const [sixs, setSixs] = useState(0)
const [fours, setFours] = useState(0)


Each state tracks a separate value â€” total runs, sixes, and fours.

âœ… Event Handlers
const handleSingle = () => setRuns(runs + 1)
const handleFour = () => {
  setRuns(runs + 4)
  setFours(fours + 1)
}
const handleSix = () => {
  setRuns(runs + 6)
  setSixs(sixs + 1)
}


Each button click updates both the total score and the related count correctly.
React automatically re-renders the UI when any of these state values change.

âœ… UI Output
<p>Total Fours: {fours} and Total sixes: {sixs}</p>
<h2>Score: {runs}</h2>


Every click instantly updates the displayed data â€” no manual DOM manipulation needed.

2. App.jsx â€” Parent Component

Here you are importing and rendering the Batsman component:

import Batsman from './Batsman'

function App() {
  return (
    <>
      <Batsman></Batsman>
    </>
  )
}


âœ… Batsman is being used as a child component, and since it handles its own state internally, no props or extra setup is required.

ğŸ§  Why This Is Great React Practice

Youâ€™re keeping state local to the component that uses it (Batsman).

App remains clean and focuses only on layout or routing.

Each component does one job â€” this is perfect React design.










39-6 Load dynamic data, API call using use/////////////////
1ï¸âƒ£ You wrote:
const fetchFriends = async () => {
  const res = await fetch('https://jsonplaceholder.typicode.com/users')
  return res.json()
}


âœ… This returns a promise that resolves to your list of friends.

2ï¸âƒ£ Inside App()
const friendsPromise = fetchFriends()


Youâ€™re creating the promise directly inside App() and passing it as a prop:

<Friends friendsPromise={friendsPromise} />


So Friends receives that promise and can â€œsuspendâ€ until the data is ready.

3ï¸âƒ£ Inside Friends()
import { use } from "react"

export default function Friends({ friendsPromise }) {
  const friends = use(friendsPromise)
  return <h3>Friend: {friends.length}</h3>
}


âœ… Here, the new React use() hook (experimental as of React 19) automatically waits for the promise to resolve.
When friendsPromise resolves, React re-renders the component with the fetched data.

4ï¸âƒ£ Suspense boundary
<Suspense fallback="Loading for data">
  <Friends friendsPromise={friendsPromise} />
</Suspense>


While the promise is still pending, the Suspense boundary shows "Loading for data".

When itâ€™s resolved, React renders <Friends> with real data.